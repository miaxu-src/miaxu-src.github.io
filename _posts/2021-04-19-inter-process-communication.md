---
category: program
title: Inter-process communication - Part 2
---

In <a href="https://miaxu-src.github.io/program/2021/03/31/inter-process-communication.html">the last blog</a>,
I have discussed two IPC methods: Pipe and FIFO. In this blog, I will continue this topic and talk about
two other IPC methods: Signal and Semaphores.


## 2. Different ways for IPC (Cont'd)
There are several ways for IPC, including pipe, FIFO, message queue, signal, and socket etc.

### 2.3. Signal
Signals are a mechanism used to notify a process that some condition has happened, e.g.,
a user has pressed `Ctrl-C` to terminate the process.
A signal can come from hardware or software (e.g., sent from another process).

Once a process receives a signal, it has three options to deal with the signal:
1. Take a default action. Linux has defined default actions for each signal. For example, for a `SIGINT`
signal (typically generated by pressing `Ctrl-C`), the default action is to terminate.
2. Ignore the signal. If a signal can be ignored and the process indeed has specified it wants to ignore
such a signal, then no action will be taken against this signal. Please note that not all signals can be ignored.
For example, `SIGKILL` and `SIGSTOP` cannot be ignored.
3. Catch the signal. If the process has specified a function to catch this signal (aka, signal handler),
the function will be called whenever the signal occurs. By providing our own function, we can handle the signal as we wish.
Similarly, `SIGKILL` and `SIGSTOP` cannot be catched by user-defined functions.

### 2.4. Semaphores
A semaphore is a counter that provides access to shared resources for multiple processes.
To access shared resources, a process must do the following:
1. Test the semaphore, which is a counter, that controls the resource.
2. If the counter is positive, the process can access the resource.
In this case, it decreases the counter by 1, which means the resource is being used.
3. Otherwise, the process goes to sleep until the counter becomes positive again. It then goes to step 1 and re-test the counter.
4. When the process finishes the access, it increases the counter by 1, indicating that it has released this resources.

There are two primitives defined for semaphore operations: `P` and `V`.
The operation `P` (also called `wait(semaphore)`) decreases the semaphore and `V` (also called `signal(semaphore)`) increases the semaphore.
Both operations are atomic. For this reason, they are typically implemented inside the kernel.

There is another concept called "Mutex". Sometimes people are confused with the two concepts and think they are the same.
In fact, "Mutex" and "Semaphores" are different concepts. Mutex is a kind of <em>locking</em> mechanism
that makes sure only one process or one thread can accquire the resource (i.e., exclusively use the resource) at a time.
Others must wait for the user who owns that resource at that time to release the lock.
However, semaphore is a kind of <em>signaling</em> mechanism, which means a process or a thread
that is waiting on a semaphore can be signaled by any one who releases the shared resources.
Therefore, a mutex is always a binary value (0 or 1), but a semaphore can be any non-positive value (much more like a counter).

<strong>Reference:</strong>

- Advanced Programming in the UNIX Environment:
<a href="http://poincare.matf.bg.ac.rs/~ivana/courses/ps/sistemi_knjige/pomocno/apue/APUE/0201433079/ch15lev1sec8.html">15.8. Semaphores</a>
- <a href="Mutex vs Semaphore">Mutex vs Semaphore</a>

<strong>(To be continued...)</strong>
